#ifndef _МояИгра_Н
#define _МояИгра_Н
#include <SFML/Graphics.hpp>	//аудио 
#include <SFML/Audio.hpp>		//графика
#include <sstream>				//работа с текстом
#include <random>				//случайные числа
#include <list>					//массив обьектов
//скаченые библиотеки совместимости с программами SpriteDecomposer и Tiled
#include "Анимация.h"
#include "level.hpp"
using namespace sf;

static int Клетка = 100;	//размер 1 клетки в пикселях

//обстрактный базовый класс
class объект
{
protected:
	std::vector<Object> обьект;		//обьекты, с которыми класс будит взаимодействовать (стены, бонусы)
	std::string имя;				//имя обьекта, нужно чтобы различать их в массиве
	bool выстрел = 0;				//флаг состояния выстрела
	bool смерть = 0;				//флаг состояния удара
	int кадуд;						//сколько кадров в анимации удара
	std::string текст;				//сообщения для вывода над персонажем
	bool жив, зеркало;				//флаг жизни и поворота
	bool приследование = 0;			//флаг состояния вписледования персонажа
	double Жизнь, урон;
	bool t = 1; bool уд = 1;		//вспомогательные флаги для анимации
	double x, y, dx, dy, w, h;		//размеры и скорость обьекта
	менеджер_анимации анимация;		//анимация
public:
	//доступ к переменным
	менеджер_анимации пок_анимация() { return анимация; };
	void изм_Жизнь(double x) { Жизнь = x; };
	double пок_Жизнь() { return Жизнь; };
	double пок_урон() { return урон; };
	int пок_кадуд() { return кадуд; };
	bool пок_уд() { return уд; };
	void изм_уд() { уд = 0; };
	bool пок_t() { return t; };
	void изм_t(bool x) { t = x; };
	bool пок_приследование() { return приследование; };
	void изм_приследование(bool x) { приследование = x; };
	bool пок_жив() { return жив; };
	void изм_жив(bool x) { жив = x; };
	bool пок_зеркало() { return зеркало; };
	void изм_зеркало(bool x) { зеркало = x; };
	std::string пок_имя() { return имя; };
	std::string пок_текст() { return текст; };
	bool пок_выстрел() { return выстрел; };
	void сдел_выстрел() { выстрел = 1; };
	double пок_h() { return h; };
	double пок_x() { return x; };
	void изм_x(double х) { x = х; };
	double пок_y() { return y; };
	void изм_y(double х) { y = х; };
	//основные функции
	объект(менеджер_анимации a, int X, int Y); //конструктор
	FloatRect размер();	//возращает размеры персонажа
	virtual void показать(RenderWindow& window); //отобразить персонажа
	virtual void option(std::string NAME, double SPEED = 0, double жизнь = 1, std::string FIRST_ANIM = ""); //инициализовать начальные характеристики
	virtual void обновить(double время) = 0; //основная ф-ия, обновляет персонажа
};

class Игрок : public объект
{
private:
	int ЗапасСтрел = 10;			//сколько осталось выстрелов
	double скорасть_игрока = 0.3;	//скорость игрока пешком
	FloatRect позиция;				//координаты
	bool на_земле = 0;				//нужно ли придовать ускорение падения
	Sprite игрок;					//картинка
public:
	//доступ к переменным
	int пок_ЗапасСтрел() { return ЗапасСтрел; };
	void изм_ЗапасСтрел(int x) { ЗапасСтрел = x; };
	void доб_ЗапасСтрел(int x) { ЗапасСтрел += x; };
	//основные функции
	Игрок(менеджер_анимации& анимация, Level& lvl, int x, int y); //конструктор
	void Анимация(double time); //анимация
	void НачПозиц(char буква);	//чтение начальной позиции
	void yправление();			//управление персонадем
	void обновить(double время); //основная ф-ия, обновляет персонажа
	bool столкновение(bool ось); //взаимоотношение со стенами
};

class Стрела : public объект {
public:
	Стрела(менеджер_анимации& a, Level& lev, int x, int y, bool dir); //свой конструктор
	void обновить(double time); //основная ф-ия, обновляет персонажа
	Стрела(менеджер_анимации& a, Level& lev, int x, int y) : объект(a, x, y) {} //конструктор для связи потомков с предками
};

class Камень : public Стрела {
public:
	Камень(менеджер_анимации& a, Level& lev, int x, int y, bool dir); //конструктор
};

class Бонус : public объект {
public:
	Бонус(std::string NAME, менеджер_анимации& a, int x, int y) : объект(a, x, y) {//конструктор
		option(NAME); //загрузка основных параметров
	}
	void обновить(double time) {}; //обновление не требуется
};

class Гоблин : public объект {
protected:
	bool выстрел2 = 0;		//у наследников много типов ударов, но все пользуются обновлением гоблина
	bool направление = 0;	//куда двигаться
	int смер = 0;			//нужен чтобы загружать разные по размерам картинки смерти персонажа
	bool f = 1;				//флаг для проигрывания анимациии смерти

	double скорость = 0.3;	//стартовая скорость
	bool на_земле = 0;		//нужно ли придовать ускорение падения

public:
	//доступ к переменным
	void изм_выстрел2(bool x) { выстрел2 = x; };
	//основные функции
	virtual void поведение();//что делать после встречи с припядствием
	virtual void Анимация(double time);//анимация персонажа
	Гоблин(менеджер_анимации& анимация, Level& lvl, int x, int y, double SPEED, double жизнь); //конструктор
	Гоблин(менеджер_анимации& a, Level& lev, int x, int y) : объект(a, x, y) {} //связь наследников с предками
	void обновить(double время); //основная ф-ия, обновляет персонажа
	bool столкновение(bool ось); //взаимоотношение со стенами
};

class Нпс1 : public Гоблин {
protected:
	int удар = 0;	//переключатель типов ударов
public:
	virtual void Анимация(double time); //проигрывать анимацию
	Нпс1(менеджер_анимации& анимация, Level& lvl, int x, int y); //конструктор
};

class Халк : public Гоблин {
protected:
	bool прыжок = 0; //флаг начала прыжка
	//флаги для анимаций
	bool t4 = 1;
	bool t3 = 0;
	double t2; //запоминанее позиции чтобы сменить повиденее при повторении пути
	double выспрышеп = 0.6; //ускорение при прышке
	int удар = 0; // который удар проигрывать

public:
	//доступ к переменным
	int пок_удар() { return удар; };
	//основные функции
	virtual void Анимация(double time); //проигрывать анимацию
	void поведение(); //что делать при встречи со стеной
	Халк(менеджер_анимации& анимация, Level& lvl, int x, int y); //конструктор
	Халк(менеджер_анимации& анимация, Level& lvl, int x, int y, int t) : Гоблин(анимация, lvl, x, y) {} //конструктор для связи наследников с предками
};

class Бос : public Халк {
private:
	double прыжокустены; //запоминанее позиции чтобы сменить повиденее при повторении пути
public:
	//доступ к переменным
	double пок_прыжокустены() { return прыжокустены; };
	//основные функции
	void Анимация(double time); //проигрыванее анимации
	Бос(менеджер_анимации& анимация, Level& lvl, int x, int y); //конструктор
};
#endif